package beibao;

public class NewBeibao {

    /**
     * https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg
     * 有  件物品和一个容量是  的背包。每件物品有且只有一件。
     *
     * 第  件物品的体积是 ，价值是 。
     *
     * 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
     *
     * 示例 1：
     *
     * 输入: N = 3, V = 4, v = [4,2,3], w = [4,2,3]
     * 输出: 4
     * 解释: 只选第一件物品，可使价值最大。
     * 示例 2：
     *
     * 输入: N = 3, V = 5, v = [4,2,3], w = [4,2,3]
     * 输出: 5
     * 解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大。
     */

    /**
     * 二维数组dp 考虑前  件物品，使用容量不超过  的条件下的背包最大价值。
     *
     * 当有了状态定义之后，我们再根据「最后一步」选择来推导「状态转移方程」。
     *
     * 不失一般性的，我们只需要考虑第  件物品如何选择即可，对于第  件物品，我们有「选」和「不选」两种决策。
     *
     * 结合我们的「状态定义」，「不选」方案的「最大价值」很好确定：
     *
     * 「不选」其实就是 ，等效于我们只考虑前  件物品，当前容量为  的情况下的最大价值。
     *
     * 同理，如果我们选第  件物品的话，代表消耗了  的背包容量，获取了  的价值，那么留给前  件物品的背包容量就只剩 。即最大价值为 。
     *
     * 当然，选第  件有一个前提：「当前剩余的背包容量」「物品的体积」。
     *
     * 在「选」和「不选」之间取最大值，就是我们「考虑前  件物品，使用容量不超过  」的条件下的「背包最大价值」。
     *
     * 即可得「状态转移方程」为：
     */
    public int maxValue(int N, int C, int[] v, int[] w) {
        int[][] dp = new int[N][C + 1];
        // 先处理「考虑第一件物品」的情况
        for (int i = 0; i <= C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        // 再处理「考虑其余物品」的情况
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < C + 1; j++) {
                // 不选该物品
                int n = dp[i - 1][j];
                // 选择该物品，前提「剩余容量」大于等于「物品体积」
                int y = j >= v[i] ? dp[i - 1][j - v[i]] + w[i] : 0;
                dp[i][j] = Math.max(n, y);
            }
        }
        return dp[N - 1][C];
    }

    /**
     * dp[2][c] 因为当前选择个数仅取决于前一个
     */
    public int maxValue1(int N, int C, int[] v, int[] w) {
        int dp[][] = new int[2][C + 1];
        //只考虑装第一件物品
        for (int i = 0; i <= C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < C + 1; j++) {
                //不选
                int n = dp[(i - 1) & 1][j];
                int y = j >= v[i] ? dp[(i - 1) & 1][j - v[i]] + w[i] : 0;
                dp[i & 1][j] = Math.max(n, y);
            }
        }
        return dp[(N - 1) & 1][C];
    }

    /**
     * dp[c]  只与容量有关系
     */
    public int maxValue2(int N, int C, int[] v, int[] w) {
        int dp[] = new  int[C+1];

        // 倒着排序是为了防止重复选择  一层一层---
        for (int i = 0; i < N; i++) {
            for (int j = C; j >= v[i]; j--) {
                // 不选该物品
                int n = dp[j];
                // 选择该物品
                int y = dp[j-v[i]] + w[i];
                dp[j] = Math.max(n, y);
            }
        }
        return dp[C];
    }


}
